{"version":3,"sources":["parser/src/util.ts","parser/src/LexicalAnalyzer.ts","parser/src/Tree.ts","parser/src/Parser.ts","tests/test-generator.ts","App.tsx","index.tsx"],"names":["Token","blanks","operations","AND","OR","XOR","NOT","LexicalAnalyzer","expression","curPos","curChar","curToken","lastVariable","this","nextChar","skipWS","isLetter","getVariableOrOperation","isLParen","LPAREN","isRParen","RPAREN","isEnd","END","Error","VAR","token","prevChar","length","regex","test","isMatch","includes","id","Tree","name","children","Parser","lex","nextToken","tree","E","getToken","AssertionError","message","getNonEmpty","T","E1","op","getTokenName","F","T1","n","push","nodes","filter","node","vars","binary","not","expr","brackets","App","useState","state","setState","err","setErr","data","setData","inputRef","useRef","testsValid","useMemo","tests","forEach","v","bin","generateCorrectExpressions","testsInvalid","generateIncorrectExpressions","useEffect","current","classList","remove","result","parse","add","e","calc","value","onSuggestClick","Math","floor","random","className","style","width","height","rootNodeClassName","branchNodeClassName","leafNodeClassName","orientation","onClick","type","defaultValue","ref","onKeyDown","event","key","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6f48ce86.chunk.js","sourcesContent":["import Tree from \"./Tree\";\r\n\r\nexport const enum Token {\r\n    VAR, AND= 'and', OR = 'or', XOR = 'xor', NOT = 'not', LPAREN = '(', RPAREN = ')', END = '$'\r\n}\r\n\r\nexport type Result = Tree | \"\";\r\n\r\nexport type ParseException = typeof Error;\r\n\r\nexport const blanks: string[] = [' ', '\\r', '\\n', '\\t'];\r\n\r\nexport const operations: Record<string, Token> = {\r\n    'and': Token.AND,\r\n    'or': Token.OR,\r\n    'xor': Token.XOR,\r\n    'not': Token.NOT\r\n}","import {blanks, operations, ParseException, Token} from \"./util\";\r\n\r\nclass LexicalAnalyzer {\r\n    private readonly expression: string;\r\n    private curPos: number = -1;\r\n    private curChar!: string;\r\n    private curToken!: Token;\r\n    private lastVariable!: string;\r\n\r\n    constructor(expression: string) {\r\n        this.expression = expression + '$';\r\n    }\r\n\r\n    public nextToken(): void | ParseException {\r\n        this.nextChar();\r\n        this.skipWS();\r\n        switch (true) {\r\n            case this.isLetter():\r\n                this.curToken = this.getVariableOrOperation();\r\n                return;\r\n            case this.isLParen():\r\n                this.curToken = Token.LPAREN;\r\n                return;\r\n            case this.isRParen():\r\n                this.curToken = Token.RPAREN;\r\n                return;\r\n            case this.isEnd():\r\n                this.curToken = Token.END;\r\n                return;\r\n            default:\r\n                throw new Error(`Illegal char '${this.curChar}' at position ${this.curPos}`);\r\n        }\r\n    }\r\n\r\n    public getToken(): Token {\r\n        return this.curToken;\r\n    }\r\n\r\n    public getPos(): number {\r\n        return this.curPos;\r\n    }\r\n\r\n    public getTokenName(): string {\r\n        return this.curToken === Token.VAR ? this.lastVariable : this.curToken;\r\n    }\r\n\r\n    private nextChar(): void | ParseException {\r\n        this.curChar = this.expression[++this.curPos];\r\n    }\r\n\r\n    private prevChar(): void | ParseException {\r\n        this.curChar = this.expression[--this.curPos];\r\n    }\r\n\r\n    private getVariableOrOperation() : Token {\r\n        let token: string = '';\r\n        while (this.isLetter()) {\r\n            token += this.curChar;\r\n            this.nextChar();\r\n        }\r\n        this.prevChar();\r\n        this.lastVariable = token.length === 1 ? token : '';\r\n        if (!operations[token] && !this.lastVariable) {\r\n            throw new Error(`Illegal variable '${token}' at pos ${this.curPos}`)\r\n        }\r\n        return operations[token] || Token.VAR;\r\n    }\r\n\r\n\r\n    private isMatch(regex: RegExp) : boolean {\r\n        return regex.test(this.curChar);\r\n    }\r\n\r\n    private isLetter() : boolean {\r\n        return this.isMatch(/^[a-z]$/);\r\n    }\r\n\r\n    private isLParen() : boolean {\r\n        return this.isMatch(/^\\($/);\r\n    }\r\n\r\n    private isRParen() : boolean {\r\n        return this.isMatch(/^\\)$/);\r\n    }\r\n\r\n    private isEnd() : boolean {\r\n        return this.isMatch(/^\\$$/);\r\n    }\r\n\r\n    private skipWS(): void {\r\n        while (blanks.includes(this.curChar)) {\r\n            this.nextChar();\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport default LexicalAnalyzer;","let id = 0;\r\n\r\nclass Tree {\r\n    name: string;\r\n    children?: Tree[];\r\n    id: number;\r\n\r\n    constructor(name: string, ...children: Tree[]) {\r\n        this.name = name;\r\n        if (id > 1e6) id = 0;\r\n        this.id = id++;\r\n        if (children.length) {\r\n            this.children = children;\r\n        }\r\n    }\r\n}\r\n\r\nexport default Tree;\r\n","import LexicalAnalyzer from \"./LexicalAnalyzer\";\r\nimport Tree from \"./Tree\";\r\nimport {Result, Token} from \"./util\";\r\nimport {AssertionError} from \"assert\";\r\n\r\nclass Parser {\r\n    private lex!: LexicalAnalyzer;\r\n\r\n    public parse(expression: string): Tree {\r\n        this.lex = new LexicalAnalyzer(expression);\r\n        this.lex.nextToken();\r\n        const tree = this.E() as Tree;\r\n        if (this.lex.getToken() !== Token.END) {\r\n            throw new AssertionError({message: \"Invalid expression\"});\r\n        }\r\n        return tree;\r\n    }\r\n\r\n    private E(): Result {\r\n        switch (this.lex.getToken()) {\r\n            case Token.VAR:\r\n            case Token.NOT:\r\n            case Token.LPAREN:\r\n                return new Tree(\"E\", ...Parser.getNonEmpty(this.T(), this.E1()));\r\n            default:\r\n                throw new AssertionError({message: \"Expected variable, 'not' or '('\"});\r\n        }\r\n    }\r\n\r\n    private E1(): Result {\r\n        switch (this.lex.getToken()) {\r\n            case Token.OR:\r\n            case Token.XOR:\r\n                const op = new Tree(this.lex.getTokenName());\r\n                this.lex.nextToken();\r\n                return new Tree(\"E'\", ...Parser.getNonEmpty(op, this.T(), this.E1()));\r\n            default:\r\n                return \"\";\r\n        }\r\n    }\r\n\r\n    private T(): Result {\r\n        switch (this.lex.getToken()) {\r\n            case Token.VAR:\r\n            case Token.NOT:\r\n            case Token.LPAREN:\r\n                return new Tree(\"T\", ...Parser.getNonEmpty(this.F(), this.T1()));\r\n            default:\r\n                throw new AssertionError({message: \"Expected variable, 'not' or '('\"});\r\n        }\r\n    }\r\n\r\n    private T1(): Result {\r\n        switch (this.lex.getToken()) {\r\n            case Token.AND:\r\n                const op = new Tree(this.lex.getTokenName());\r\n                this.lex.nextToken();\r\n                return new Tree(\"T'\", ...Parser.getNonEmpty(op, this.F(), this.T1()));\r\n            default:\r\n                return \"\";\r\n        }\r\n    }\r\n\r\n    private F(): Result {\r\n        switch (this.lex.getToken()) {\r\n            case Token.VAR:\r\n                const n = new Tree(this.lex.getTokenName());\r\n                this.lex.nextToken();\r\n                return new Tree(\"F\", n);\r\n            case Token.NOT:\r\n                const op = new Tree(this.lex.getTokenName());\r\n                this.lex.nextToken();\r\n                return new Tree(\"F\", ...Parser.getNonEmpty(op, this.F()));\r\n            case Token.LPAREN:\r\n                const children: Result[] = [new Tree(this.lex.getTokenName())]\r\n                this.lex.nextToken();\r\n                children.push(this.E());\r\n                if (this.lex.getToken() !== Token.RPAREN) {\r\n                    throw new AssertionError({message: \"Unclosed brackets\"});\r\n                }\r\n                children.push(new Tree(Token.RPAREN));\r\n                this.lex.nextToken();\r\n                return new Tree(\"F\", ...Parser.getNonEmpty(...children));\r\n            default:\r\n                throw new AssertionError({message: \"Expected variable, 'not' or '('\"});\r\n        }\r\n    }\r\n\r\n    private static getNonEmpty(...nodes: Result[]): Tree[] {\r\n        return nodes.filter(node => node !== '') as Tree[];\r\n    }\r\n}\r\n\r\nexport default Parser;","const vars = ['a', 'b', 'c'];\r\nconst binary = ['or', 'xor', 'and'];\r\nconst not = (expr: string) => `not ${expr}`\r\nconst brackets = (expr: string) => `(${expr})`\r\n\r\nexport const generateCorrectExpressions = () => {\r\n    const tests: string[] = [];\r\n    vars.forEach((v) => {\r\n        tests.push(v);\r\n        tests.push(not(v));\r\n        tests.push(not(not(v)));\r\n        tests.push(brackets(not(v)));\r\n        tests.push(brackets(brackets(v)));\r\n        tests.push(not(brackets(v)));\r\n        binary.forEach((bin) => {\r\n            tests.push(`${v} ${bin} ${v}`);\r\n            tests.push(brackets(`${v} ${bin} ${v}`));\r\n            tests.push(`${brackets(`${v} ${bin} ${v}`)} ${bin} ${v}`);\r\n            tests.push(`${brackets(`${v} ${bin} ${v}`)} ${bin} ${brackets(`${v} ${bin} ${v}`)}`);\r\n\r\n            tests.push(not(`${v} ${bin} ${v}`));\r\n            tests.push(not(brackets(`${not(v)} ${bin} ${not(v)}`)));\r\n            tests.push(not(`${brackets(`${not(v)} ${bin} ${not(v)}`)} ${bin} ${not(v)}`));\r\n            tests.push(not(`${brackets(`${not(v)} ${bin} ${not(v)}`)} ${bin} ${brackets(`${not(v)} ${bin} ${not(v)}`)}`));\r\n        })\r\n        tests.push('(a and b) or not (c xor (a or not b))');\r\n        tests.push('a and not (b or not c)');\r\n        tests.push('not a and (not b or x)');\r\n        tests.push('(a xor not a) or (x and not not b)');\r\n    })\r\n    return tests;\r\n}\r\n\r\nexport const generateIncorrectExpressions = () => {\r\n    const tests: string[] = [];\r\n    tests.push('');\r\n    tests.push('(');\r\n    tests.push(')');\r\n    tests.push('()');\r\n    tests.push('(a');\r\n    tests.push('a)');\r\n    tests.push('not');\r\n    tests.push('not (');\r\n    tests.push('not )');\r\n    tests.push('(not)');\r\n    tests.push('a not');\r\n    tests.push('a a');\r\n    tests.push('A');\r\n    tests.push('asd');\r\n    tests.push('anot');\r\n    tests.push('a(not');\r\n    tests.push('and');\r\n    tests.push('or');\r\n    tests.push('xor');\r\n    tests.push('nota');\r\n    tests.push('ora');\r\n    tests.push('xora');\r\n    tests.push('anda');\r\n    tests.push('( and');\r\n    tests.push('( or');\r\n    tests.push('( xor');\r\n    tests.push('( a and');\r\n    tests.push('( a or');\r\n    tests.push('( a xor');\r\n    tests.push('( a and)');\r\n    tests.push('( a or)');\r\n    tests.push('( a xor)');\r\n    tests.push('a and and');\r\n    tests.push('a or or');\r\n    tests.push('a xor xor');\r\n    tests.push('a and or');\r\n    tests.push('not and');\r\n\r\n    return tests;\r\n}","import React, {useEffect, useMemo, useRef, useState} from 'react';\nimport './App.css';\nimport 'react-tree-graph/dist/style.css'\nimport Parser from \"./parser/src/Parser\";\nimport Tree from \"./parser/src/Tree\";\nimport TreeVisual from \"react-d3-tree\";\nimport {Result} from \"./parser/src/util\";\nimport {generateCorrectExpressions, generateIncorrectExpressions} from \"./tests/test-generator\";\n\nfunction App() {\n    const [state, setState] = useState(\"(a and b) or not (c xor (a or not b))\");\n    const [err, setErr] = useState('')\n    const [data, setData] = useState<Result>(\"\")\n    const inputRef = useRef<HTMLInputElement>(null);\n\n    const testsValid = useMemo(() => generateCorrectExpressions(), []);\n    const testsInvalid = useMemo(() => generateIncorrectExpressions(), []);\n\n    useEffect(() => {\n        try {\n            setErr('')\n            inputRef.current!.classList.remove('warn');\n            const result: Tree = new Parser().parse(state);\n            setData(result);\n            inputRef.current!.classList.add('success');\n        } catch (e) {\n            inputRef.current!.classList.remove('success');\n            inputRef.current!.classList.add('warn');\n            // @ts-ignore\n            setErr(e.message)\n        }\n    }, [state])\n\n    const calc = () => {\n        setState(inputRef.current!.value);\n    }\n\n    const handleKeyDown = (event: any) => {\n        if (event.key === 'Enter') {\n            calc()\n        }\n    }\n\n    const onSuggestClick = (tests: string[]) => {\n        inputRef.current!.value = tests[Math.floor(Math.random() * tests.length)];\n        calc();\n    }\n\n    return (\n        <div className=\"App\">\n            {\n                data &&\n                <div id=\"treeWrapper\" style={{width: '100vw', height: '100vh'}}>\n                    <TreeVisual\n                        data={data}\n                        rootNodeClassName=\"node__root\"\n                        branchNodeClassName=\"node__branch\"\n                        leafNodeClassName=\"node__leaf\"\n                        orientation=\"vertical\"\n                    />\n                </div>\n            }\n            <div className=\"input_expression\">\n                <div className=\"suggests\">\n                    <button onClick={() => onSuggestClick(testsValid)}>GENERATE VALID</button>\n                    <button onClick={() => onSuggestClick(testsInvalid)}>GENERATE INVALID</button>\n                </div>\n                <input type=\"text\" defaultValue={state} ref={inputRef} onKeyDown={handleKeyDown}/>\n                <div className=\"error\">{err}</div>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}